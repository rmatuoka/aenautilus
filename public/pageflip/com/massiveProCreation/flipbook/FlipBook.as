package com.massiveProCreation.flipbook{	// IMPORTS		import com.asual.swfaddress.*;	import com.greensock.TweenMax;	import com.greensock.easing.*;	import com.massiveProCreation.events.*;	import com.massiveProCreation.flipbook.ui.Alert;	import com.massiveProCreation.flipbook.ui.GoToPage;	import com.massiveProCreation.flipbook.ui.PageContent;	import com.massiveProCreation.flipbook.ui.TableOfContent;	import com.massiveProCreation.utils.ImagePreloader;	import com.massiveProCreation.utils.graphics.Cover;	import com.massiveProCreation.utils.loaders.XMLLoaderImproved;	import com.massiveProCreation.utils.video.VideoPlayer;		import fl.motion.CustomEase;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.ProgressEvent;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	import flash.net.URLRequest;	import flash.net.navigateToURL;		public class FlipBook extends Sprite	{ 		// LOADERS		private var _xmlLoader:XMLLoaderImproved = new XMLLoaderImproved();			// custom xml loader		private var _loader:Loader = new Loader();									// loader, used to load images		// VARIABLES		private var _xml:XML ;														// xml object		private var _fbWidth:int;													// flip book width		private var _fbHeight:int;													// flip book height		private static const _rtd = 180/Math.PI;									// radians to degrees		private static const _dtr = Math.PI/180; 									// degrees to radians		public var _mouseX:Number = 0; 												// my mouseX while dragging the corner		public var _mouseY:Number = 0; 												// my mouseY while dragging the corner		private var _cornerr:Number = 0; 											// radius of the corner		private var _circler:Number = 0;											// radius of the circle		private var _pageAngle:Number = 0;  										// angle of the page		private var _activePage:String = ""; 										// page active: left, right or none		private var _currentPage:int = -1;											// currently shown page		private var _pageToLoad:int = 0;											// index of a page which will be loaded		private var _tween:Boolean = false;											// is tweening (true/false)		private var _tweenBack:Boolean = false;										// is tweening back (true/false)		private var _rightChanged:Boolean = false;									// right page changed		private var _leftChanged:Boolean = false;									// left page changed		private var _releaseX:Number = 0;											// the x position of corner when released		private var _releaseY:Number = 0;											// the y position of corner when released		private var _nopch:int = 1; 												// number of pages changes											private var _boarder:int = 0;												// the boarder		private var _ct:ColorTransform;												// color transform		private var _cs:CenterShadow = new CenterShadow();							// inner shadow		private var _csr:CenterShadowRight = new CenterShadowRight();				// center inner shadow right		private var _csl:MovieClip = new CenterShadowLeft();					// center inner shadow left		private var _pagesLoaded:int = 0;											// number of pages loaded		private var _alert:Alert;													// alert module		private var _interactive:Boolean = true;									// book interactive (true/false)		private var _gotoPage:Boolean = false;										// go to page (true/false)		private var _pages:Array = new Array();										// array containg pages		private var _fbm:FlipBookMasks = new FlipBookMasks();						// MovieClip which contains masks and shadows used in the flip book		private var _pageBG:PageBG;													// page background		private var _imagePreloader:ImagePreloader = new ImagePreloader();			// image preloader		private var _numberOfAllPages:int;											// number of all pages		private var _vp:VideoPlayer;		private var _toc:TableOfContent;											// table of content		private var _resizeSwf:Boolean = true										// resize swf's		private var _resizeContent:Boolean = false;									// resize content		private var _resizeToc:Boolean = false;		private var _reverse:Boolean = false;										// reverse the book		private var _goToPage:GoToPage = new GoToPage();							// go to page		private var _pageNumber:PageNumber = new PageNumber();		private var _pageContent:PageContent;		private var _title:String = "";		private var _whereToStart:int = 0;		private var _whereToAdd:int = 0;		private var _gtp:int = -1;		private var _cover:Cover = new Cover();				public function FlipBook()		{			super();																// constructor call, super, add stage event			this.addEventListener(Event.ADDED_TO_STAGE, added, false, 0, true);		}		// ADDED TO STAGE FUNCTION //		protected function added(e:Event):void {			stage.addEventListener(Event.RESIZE, onResize, false, 0, true);			this.addEventListener(Event.REMOVED_FROM_STAGE, onRemove, false, 0, true);		}		// XML LOADED ASSIGN IT TO _xml VARIABLE //		private function xmlLoaded(e:CustomEvent = null):void {						// when xml loaded cound the flipbook width and height			/* Draw data from the XML */			_fbWidth = int(_xml.@width);			_fbHeight = int(_xml.@height);			_boarder = int(_xml.@boarder);									if(String(_xml.@resizeSwf) == "true")				_resizeSwf = true;			else				_resizeSwf = false;							if(String(_xml.@resizeContent) == "true")				_resizeContent = true;			else				_resizeContent = false;							if(String(_xml.@resizeTableOfContent) == "true")				_resizeToc = true;			else				_resizeToc = false;							if(String(_xml.@reverse) == "true")				_reverse = true;			else				_reverse = false;						if(_fbHeight == 0 || _fbWidth == 0){				_fbHeight = stage.stageHeight - 125;				_fbWidth = ((stage.stageHeight - 125) * Number(_xml.@proportion))*2;			}						var length:int = _xml.page.length();						for(var i:int = 0; i < length; i++){					// set the number of all pages				if(String(_xml.page[i].@type) == "double"){					var obj:Object = {load:"loading", id:i};									_numberOfAllPages++; 					_pages.push(obj);					} 								obj = {load:"loading", id:i};				_pages.push(obj);											_numberOfAllPages++; 				if(_numberOfAllPages < _whereToStart)					_pageToLoad ++;			}						stage.dispatchEvent(new Event(Event.RESIZE));					if(_reverse){				_pageToLoad = _xml.page.length() - 1;				_currentPage = _numberOfAllPages - 1;							}			if(_whereToStart > 0)				_whereToAdd = _pagesLoaded =  _whereToStart-1;			else				_whereToAdd = _pagesLoaded = _pageToLoad = _whereToStart;									loadPage(_pageToLoad);																// at the end call the loadPage funciton					/* Set objects names */			_cover.name = "cover";		}		private function loadPage(id:int):void {											// this function loads pages			try{				_loader.unload();			} catch(e:Error){				trace("er");			}						_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, pageLoaded, false, 0, true);			_loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, imageLoadProgress, false, 0, true);			_loader.load(new URLRequest(String(_xml.page[id].@src)));		}		private function imageLoadProgress(e:ProgressEvent):void {				// image load progres, update preloader			_imagePreloader.updateBar(e.bytesLoaded, e.bytesTotal);					}		private function pageLoaded(e:Event):void {			/* When page loaded we check if its a bitmap and if its double, if its double the bitmap is redrawn into 			 * two smaller bitmaps, and then added to the _pages array, otherwise is added to the array tight away 			 * if there are more pages to load the loadPage function is called other wise the load pages proces stops 			 * When the number of pages loaded is greater or equal to the load value specified by user in the xml file			 * the flipbook is shown, the initFlipbook function is called.			 */						var load:int;			var bs:Boolean;			var sprite:Sprite;			var sprBg:Sprite;						if(_pages == null)				return;							if(String(_xml.@bitmapSmoothing) == "true")				bs = true;			else 				bs = false;								if(_reverse){				load = _numberOfAllPages;			} else {				load = int(_xml.@load);			}					if(String(_xml.page[_pageToLoad].@type) == "video"){				_vp = new VideoPlayer({src:String(_xml.page[_pageToLoad].@videoSrc), bufferTime:10, volume:0.5, smoothing:true, 					autoAdjust:false, maxWidth:(_fbWidth/2) - (_boarder * 5), maxHeight:_fbHeight-(_boarder * 5), 					rollOver:String(_xml.alert.video.enlarge.@src), preloading:String(_xml.alert.video.preloading.@src), 					duration:Number(_xml.page[_pageToLoad].@duration), width:Number(_xml.page[_pageToLoad].@width), height:Number(_xml.page[_pageToLoad].@height)});				sprite = new Sprite();				sprBg = new Sprite();				sprBg.addChild(_loader.content);				sprite.addChild(sprBg);				sprite.addChild(_vp);				_vp.x = (_boarder/2) + (sprite.width - _vp.width ) / 2;				_vp.y = (sprite.height - _vp.height ) / 2;				_vp.addEventListener(CustomEvent.ADJUST_VIDEO, videoPosition, false, 0, true);				_vp.alpha = 0;				_vp.addEventListener(Event.ADDED_TO_STAGE, setAdded, false, 0, true);				_vp.addEventListener(CustomEvent.VIDEO_READY, videoAdded, false, 0, true);				_vp.addEventListener(CustomEvent.VIDEO_CLICK, videoClick, false, 0, true);				sprite.mouseChildren = true;				_pages[_whereToAdd] = ({src:sprite, url:String(_xml.page[_pageToLoad].@url), target:String(_xml.page[_pageToLoad].@urltarget)});			} else if(String(_xml.page[_pageToLoad].@type) == "table"){					var tmpArray:Array = new Array();								for(var i:int = 0; i < _xml.page[_pageToLoad].list.length(); i++){					tmpArray.push({src:_xml.page[_pageToLoad].list[i].@src, number:_xml.page[_pageToLoad].list[i].@number});				}				_toc = new TableOfContent(tmpArray, uint(_xml.page[_pageToLoad].@bgColor), Number(_xml.page[_pageToLoad].@bgAlpha), uint(_xml.page[_pageToLoad].@textColor));				sprite = new Sprite();				sprBg = new Sprite();				sprBg.addChild(_loader.content);				sprite.addChild(sprBg);				sprite.addChild(_toc);				_toc.addEventListener(CustomEvent.ADJUST, adjustToc, false, 0, true);				_toc.callAdjust();				_pages[_whereToAdd] = ({src:sprite, url:String(_xml.page[_pageToLoad].@url), target:String(_xml.page[_pageToLoad].@urltarget)});											} else if(String(_xml.page[_pageToLoad].@type) == "content"){									_pageContent = new PageContent(String(_xml.page[_pageToLoad]), int(_xml.page[_pageToLoad].@width), int(_xml.page[_pageToLoad].@height), uint(_xml.page[_pageToLoad].@textcolor)); 				sprite = new Sprite();				sprBg = new Sprite();				sprBg.addChild(_loader.content);				sprite.addChild(sprBg);				sprite.addChild(_pageContent);				_pageContent.addEventListener(CustomEvent.ADJUST, adjustContent, false, 0, true);				_pages[_whereToAdd] = ({src:sprite, url:String(_xml.page[_pageToLoad].@url), target:String(_xml.page[_pageToLoad].@urltarget), height:int(_xml.page[_pageToLoad].@height), width:int(_xml.page[_pageToLoad].@width)});							} else {				if(String(_xml.page[_pageToLoad].@type) == "double" ){					var bitmap:Bitmap;					var bitmapData:BitmapData;										if(_loader.content is Bitmap){						var ar:Array = new Array();						ar.push(_loader.content);												var area:Rectangle = new Rectangle(0, 0, _loader.content.width/2, _loader.content.height);						bitmapData = new BitmapData(area.right, area.bottom);						bitmapData.draw(ar[0]);						bitmap = new Bitmap(bitmapData);						bitmap.smoothing  = bs;						if(_pages != null)							_pages[_whereToAdd] = ({src:bitmap, url:String(_xml.page[_pageToLoad].@url), target:String(_xml.page[_pageToLoad].@urltarget), fixe:"double"});																area = new Rectangle(0, 0 , _loader.content.width/2, _loader.content.height);						var spr:Sprite = new Sprite();						spr.addChild(ar[0]);						ar[0].x = -_loader.content.width / 2;						bitmapData = new BitmapData(area.right, area.bottom);						bitmapData.draw(spr);						bitmap = new Bitmap(bitmapData);						bitmap.smoothing  = bs;											_pages[_whereToAdd+1] = ({src:bitmap, url:String(_xml.page[_pageToLoad].@url2), target:String(_xml.page[_pageToLoad].@urltarget2)});						_pagesLoaded++;						_imagePreloader.updateText(_numberOfAllPages);						_whereToAdd++;					}									} else {					if(_loader.content is MovieClip || _loader.content is Sprite){						_pages[_whereToAdd] = ({src:_loader.content, url:String(_xml.page[_pageToLoad].@url), target:String(_xml.page[_pageToLoad].@urltarget), width:_loader.content.width, height:_loader.content.height});					} else {						if(_loader.content is Bitmap)							Bitmap(_loader.content).smoothing = bs;												_pages[_whereToAdd] = ({src:_loader.content, url:String(_xml.page[_pageToLoad].@url), target:String(_xml.page[_pageToLoad].@urltarget)});					}				}			}						if(_pages[_pages.length-1].src is Bitmap)				_pages[_pages.length-1].src.smoothing = bs;			else if(_pages[_pages.length-1].src != null && _pages[_pages.length-1].src.getChildAt(0) is Bitmap)				 	_pages[_pages.length-1].src.getChildAt(0).smoothing = bs;						if(_pagesLoaded < _whereToStart+1)				_pageToLoad++;						_pagesLoaded++;			_whereToAdd++							/* Update the page loader */				_imagePreloader.updateText(_numberOfAllPages);			if(_pagesLoaded == _numberOfAllPages)				_imagePreloader.loadEnd();						//trace(_pages[						if(_reverse){				if(_pageToLoad >= 0)					loadPage(_pageToLoad);			} else {				var fix:int = 0;				var length:int = _pages.length;				if(_pagesLoaded > _whereToStart+1){					for(i = 0; i < length; i++){						if(String(_pages[i].load) == "loading"){							_whereToAdd = i;							_pageToLoad = int(_pages[i].id);																				loadPage(int(_pages[i].id));								break;						}											}				} else if (_pagesLoaded < length){					loadPage(_pageToLoad);				}			}			if(_pagesLoaded == _whereToStart+1)				initFlipBook();			}		private function videoClick(e:CustomEvent):void {			_cover.alpha = 0;						this.parent.parent.addChild(_cover);						_cover.width = stage.stageWidth;			_cover.height = stage.stageHeight;			TweenMax.to(_cover, 1, {alpha:0.8, ease:Expo.easeOut });						e.target.pouse();			_vp = new VideoPlayer({src:e.target.src, bufferTime:10, volume:0.5, smoothing:true, autoAdjust:false, 				maxWidth:stage.stageWidth - 100, maxHeight:stage.stageHeight - 100, 				rollOver:String(_xml.alert.video.close.@src), preloading:String(_xml.alert.video.preloading.@src),				duration:e.target.videoDuration, width:e.target.videoWidth, height:e.target.videoHeight });			_vp.x = ((stage.stageWidth - 100) - ( _vp.width )) * 0.5;			_vp.y = (stage.stageHeight - 100 - _vp.height ) * 0.5;			_vp.addEventListener(CustomEvent.ADJUST_VIDEO, fullVideoPosition, false, 0, true);			_vp.alpha = 0;			_vp.addEventListener(Event.ADDED_TO_STAGE, setAdded, false, 0, true);			_vp.addEventListener(CustomEvent.VIDEO_READY, videoAdded, false, 0, true);			this.parent.parent.addChild(_vp);			_vp.addEventListener(CustomEvent.VIDEO_CLICK, videoClose, false, 0, true);			_vp.name = "videoPopUp";					}		private function videoClose(e:CustomEvent):void {			if(e.target.playing)				e.target.playClick(null);						e.target.removeEventListener(CustomEvent.ADJUST_VIDEO, fullVideoPosition);			e.target.removeEventListener(Event.ADDED_TO_STAGE, setAdded);			e.target.removeEventListener(CustomEvent.VIDEO_READY, videoAdded);			e.target.removeEventListener(CustomEvent.VIDEO_CLICK, videoClose);			TweenMax.to(_cover, 1, {alpha:0, ease:Expo.easeOut, onComplete:removeFromParent, onCompleteParams:[_cover]});			TweenMax.to(e.target, 1, {alpha:0, ease:Expo.easeOut, onComplete:removeFromParent, onCompleteParams:[e.target]});		}		private function removeFromParent(obj:DisplayObject):void {			if(obj != null && this.parent.parent.contains(obj)){				this.parent.parent.removeChild(obj);			}		}		private function fullVideoPosition(e:CustomEvent):void {			e.target.x = (stage.stageWidth  -  e.target.width ) * 0.5;			e.target.y = (stage.stageHeight  - e.target.height ) * 0.5;						e.target.setPreloaderXY(stage.stageWidth, stage.stageHeight);		}		private function setAdded(e:Event):void {			e.target.onStage = true;						if(e.target.ready && e.target.onStage)				TweenMax.to(e.target, 1, {alpha:1, delay:4, ease:Expo.easeOut, onComplete:e.target.hidePreloader});		}		private function videoAdded(e:CustomEvent):void{						if(e.target.ready && e.target.onStage)				TweenMax.to(e.target, 1, {alpha:1, delay:4, ease:Expo.easeOut, onComplete:e.target.hidePreloader});						}		private function initFlipBook():void {			dispatchEvent(new CustomEvent(CustomEvent.READY_TO_DISPLAY, true, false)); 	// we dispath the ready to display event				this.addChild(_fbm);														// then we add the flip book shadows and masks to the stage			this.addChild(_cs);						_fbm.x = _fbm.y = leftPage.x = leftPage.y = rightPage.y = 0;				// set the position and parameters of pages and masks 																			rightPage.x = _fbWidth/2;						rightPage.mouseChildren = leftPage.mouseChildren = leftPage.mouseEnabled = rightPage.mouseEnabled = true;										addChild(_pageNumber);			_pageNumber.x = _fbWidth/2;			_pageNumber.y = _fbHeight;			_pageNumber.pageNumber.text = "- | 1";						_cs.right.alpha = Number(_xml.shadows.inner.@src);							// setup the alpha property of diferent shadows			_csr.alpha = Number(_xml.shadows.inner.@src);			_csl.alpha = Number(_xml.shadows.inner.@src);			_cs.mouseChildren = _cs.mouseEnabled = _csl.mouseChildren = _csr.mouseChildren = _csl.mouseEnabled = _csr.mouseEnabled = false;									_fbm.ips.alpha = Number(_xml.shadows.inner.@src);			if(_reverse)				_cs.right.alpha = 0;			else if(_whereToStart == 0 || Number(_xml.shadows.inner.@src) == 0)				_cs.left.alpha = 0;															_cs.y = _fbm.y;																// setup the x and y properties of masks and shadows			_cs.x = _fbWidth/2;			_cs.height = _fbHeight;						_fbm.sm2.y = _fbm.sm.y = -_fbHeight;																												_fbm.sm2.height = _fbm.sm.height = _fbHeight;																										_fbm.sm2.x = _fbm.sm.x = -_fbWidth;																									_fbm.sm2.width = _fbm.sm.width = _fbWidth;				_goToPage.name = "goToPage";			addChild(_goToPage);			addChild(_imagePreloader);													// setup image preloader			_imagePreloader.x = _fbWidth;			_goToPage.x = 0;			_goToPage.y = _imagePreloader.y = _fbHeight;																												// setup the properties of the four corners				cornerTopLeft.visible = cornerLeft.visible = false;			cornerTopRight.buttonMode = cornerTopLeft.buttonMode = cornerLeft.buttonMode = cornerRight.buttonMode = true; 																	cornerTopLeft.mouseChildren = cornerTopRight.mouseChildren = cornerLeft.mouseChildren = cornerRight.mouseChildren = false;																	// add the events to the four corners			cornerRight.doubleClickEnabled = true;			cornerTopRight.doubleClickEnabled = true;			cornerLeft.doubleClickEnabled = true;			cornerTopLeft.doubleClickEnabled = true;			cornerRight.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClick, false, 0, true);			cornerRight.addEventListener(MouseEvent.MOUSE_DOWN, cornerClick, false, 0, true);			cornerRight.addEventListener(MouseEvent.ROLL_OVER, cornerOver, false, 0, true);			cornerRight.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);						cornerTopRight.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClick, false, 0, true);			cornerTopRight.addEventListener(MouseEvent.MOUSE_DOWN, cornerClick, false, 0, true);			cornerTopRight.addEventListener(MouseEvent.ROLL_OVER, cornerOver, false, 0, true);			cornerTopRight.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);						cornerTopLeft.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClick, false, 0, true);			cornerTopLeft.addEventListener(MouseEvent.MOUSE_DOWN, cornerClick, false, 0, true);			cornerTopLeft.addEventListener(MouseEvent.ROLL_OVER, cornerOver, false, 0, true);			cornerTopLeft.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);						cornerLeft.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClick, false, 0, true);			cornerLeft.addEventListener(MouseEvent.ROLL_OVER, cornerOver, false, 0, true);					cornerLeft.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);			cornerLeft.addEventListener(MouseEvent.MOUSE_DOWN, cornerClick, false, 0, true);														// set the id for each corner			cornerRight.id = "rightCorner";																							cornerLeft.id = "leftCorner";			cornerTopRight.id = "rightTopCorner";			cornerTopLeft.id = "leftTopCorner";			// set the position of each corner			cornerTopRight.x = _fbWidth;			cornerTopRight.y = 0;			cornerRight.x = _fbWidth;			cornerRight.y = _fbHeight;			cornerLeft.x = 0;			cornerLeft.y = _fbHeight;			cornerTopLeft.x = 0;			cornerTopLeft.y = 0;						if(_reverse){				fillPage(0, "leftPage", true);			} else {				if(_whereToStart+1 == 1){					fillPage(_whereToStart+1, "rightPage", true);				} else {					fillPage(_whereToStart, "leftPage", true);					fillPage(_whereToStart+1, "rightPage", true);					_currentPage = _whereToStart-1;				}			}									dispatchEvent(new CustomEvent(CustomEvent.PAGE_CHANGE, true, false));				SWFAddress.setValue(_title +"/"+ (_currentPage+1));																													}		private function doubleClick(e:MouseEvent):void {			if(String(_xml.@doubleClick) == "true"){				if(e.target.id == "rightCorner" || e.target.id == "rightTopCorner"){					gotoPage(currentPage + 2, true);				} else {					gotoPage(currentPage - 2, true);				}			}		}		private function pageDoubleClick(e:MouseEvent):void {			trace("PAGE DOUBLE CLICK");			this.dispatchEvent(new CustomEvent(CustomEvent.DOUBLE_PAGE_CLICK));		}		private function cornerRelease(e:MouseEvent):void {			trace("OUT");			// when the corner is released we tween the page to its destination position			_releaseX = _mouseX;			_releaseY = _mouseY;			stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMove);			tweenBack();		}		private function cornerOver(e:MouseEvent):void {			trace("OVER");			/* This function is fired when user rolls over the corner, firs the function check if next image is laoded 			 * if its not loaded then the funciton just shows the alert, but if it's loaded the roll over events are			 * removed from the corners then the roll out event is added and the _mouseX and _mouseY is added. After that			 * the stage event is added the mouse move and mouse up. At the end we setup the right or left page for transition			 * depending wich page was rolled over.			 */			if(_currentPage != -1 && String(_pages[_currentPage -1].load) == "loading" && e.target.id == "leftCorner" || _currentPage != -1 && String(_pages[_currentPage -1].load) == "loading" && e.target.id == "leftTopCorner" ){				_alert = new Alert(String(_xml.alert.loading.@src), 3000);				stage.addChild(_alert);				_alert.x = stage.stageWidth / 2;				_alert.y = stage.stageHeight / 2;				_alert.addEventListener(CustomEvent.KILL, kill, false, 0, true);						return;			}			if(_pages[_currentPage + 2] != null && e != null && String(_pages[_currentPage + 2].load) != "loading" && e.target.id == "rightCorner" ||				e.target.id != "rightCorner" && e.target.id != "rightTopCorner" ||				_pages[_currentPage + 2] != null &&  e != null && String(_pages[_currentPage + 2].load) != "loading" && e.target.id == "rightTopCorner"  ){								cornerLeft.removeEventListener(MouseEvent.ROLL_OVER, cornerOver);				cornerTopRight.removeEventListener(MouseEvent.ROLL_OVER, cornerOver);				cornerTopLeft.removeEventListener(MouseEvent.ROLL_OVER, cornerOver);				cornerRight.removeEventListener(MouseEvent.ROLL_OVER, cornerOver);				trace("add out");				cornerLeft.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);				cornerRight.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);				cornerTopRight.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);				cornerTopLeft.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);				_activePage = e.target.id;								if(_activePage == "rightCorner"){					_mouseX = _fbWidth - 5;					_mouseY = _fbHeight - 5;				} else if (_activePage == "rightTopCorner"){					_mouseX = _fbWidth - 5;					_mouseY = 5;				} else if (_activePage == "leftCorner"){					_mouseX = 5;					_mouseY = _fbHeight - 5;				} else if (_activePage == "leftTopCorner"){					_mouseX = 5;					_mouseY = 5;				}								stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMove, false, 0, true);				stage.addEventListener(MouseEvent.MOUSE_UP, cornerRelease, false, 0, true);				stage.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_MOVE));								if (_activePage == "rightCorner" || _activePage == "rightTopCorner")					setupRightPage()				else if (_activePage == "leftCorner" || _activePage == "leftTopCorner")						setupLeftPage();			} else {				_alert = new Alert(String(_xml.alert.loadingNext.@src), 2000);				stage.addChild(_alert);				_alert.x = stage.stageWidth / 2;				_alert.y = stage.stageHeight / 2;				_alert.addEventListener(CustomEvent.KILL, kill, false, 0, true);					}		}		private function cornerClick(e:MouseEvent):void {			// When user clicks the corner roll out events are removed from all the corners 			trace("corner click");			cornerLeft.removeEventListener(MouseEvent.ROLL_OUT, cornerRelease);			cornerRight.removeEventListener(MouseEvent.ROLL_OUT, cornerRelease);			cornerTopRight.removeEventListener(MouseEvent.ROLL_OUT, cornerRelease);			cornerTopLeft.removeEventListener(MouseEvent.ROLL_OUT, cornerRelease);				}		private function kill(e:CustomEvent):void {						// this function removes alert from stage			if(_alert != null && stage.contains(_alert))				stage.removeChild(_alert);			_alert = null;		}		private function fillPage(dif:int, type:String, bg:Boolean):void {			/* This function setups the flipbook before the page is changed, it's a very important function			 * depending what type is specified, we can setup forntPage, backPage, right and left page. 			 * each of those cases adds the image to the page and the background. The image is driven from 			 * _pages array. At the end we specify the boarder width and height depending on the xml file. 			 * The inner boarder (between two pages) is also setup there.			 */			var children:Array = new Array();			var i:int = 0;						if(_pages == null)				return;						if(bg){				_pageBG = new PageBG();				_pageBG.width = _fbWidth/2;				_pageBG.height = _fbHeight;				_ct = new ColorTransform();				_ct.color = uint(_xml.@boarderColor);				_pageBG.getChildAt(0).transform.colorTransform = _ct;				_pageBG.alpha = Number(_xml.@boarderAlpha);				_pageBG.doubleClickEnabled = true;				_pageBG.addEventListener(MouseEvent.DOUBLE_CLICK, pageDoubleClick, false, 0, true);			}										switch (type) {								case "frontPage":									for(i = 0; i < _fbm.frontPage.numChildren; i++){										children.push(_fbm.frontPage.getChildAt(i));									}									for(i = 0; i < children.length ; i++){										children[i].parent.removeChild(children[i]);									}									if(bg) 										_fbm.frontPage.addChildAt(_pageBG, 0);									_fbm.frontPage.addChild(_pages[_currentPage+dif].src);									_fbm.frontPage.addChild(_csr);									_csl.mouseChildren = _csr.mouseChildren = _csl.mouseEnabled = _csr.mouseEnabled = false;									_csr.height = _fbHeight;									if(_activePage == "leftCorner" || _activePage == "leftTopCorner"){										_csr.x = _fbWidth/2;										_csr.scaleX *= -1;									} else if (_activePage == "rightCorner" || _activePage == "rightTopCorner"){										_csr.scaleX *= 1;										_csr.x = 0;									}																			break;				case "backPage":									for(i = 0; i < _fbm.backPage.numChildren; i++){										children.push(_fbm.backPage.getChildAt(i));									}									for(i = 0; i < children.length ; i++){										children[i].parent.removeChild(children[i]);									}									if(bg) 										_fbm.backPage.addChild(_pageBG);									if(_pages[_currentPage+dif].src)										_fbm.backPage.addChild(_pages[_currentPage+dif].src);									_fbm.backPage.addChild(_csl);									_csl.mouseChildren = _csr.mouseChildren = _csl.mouseEnabled = _csr.mouseEnabled = false;									_csl.height = _fbHeight;									if(_activePage == "rightCorner" || _activePage == "rightTopCorner"){										_csl.x = _fbWidth/2;										_csl.scaleX *= 1;									} else if (_activePage == "leftCorner" || _activePage == "leftTopCorner"){										_csl.scaleX *= -1;										_csl.x = 0;									}																		break;				case "rightPage":									for(i = 0; i < rightPage.numChildren; i++){										children.push(rightPage.getChildAt(i));									}									for(i = 0; i < children.length ; i++){										children[i].parent.removeChild(children[i]);									}									if(bg) 										rightPage.addChildAt(_pageBG, 0);																		if(_pages[_currentPage+dif].src != null)										rightPage.addChild(_pages[_currentPage+dif].src);																		if(_pages[_currentPage+dif].url != ""){										rightPage.buttonMode = true;										rightPage.addEventListener(MouseEvent.CLICK, pageClickedRight, false, 0, true);									} else {										rightPage.buttonMode = false;										rightPage.removeEventListener(MouseEvent.CLICK, pageClickedRight);									}									break;					case "leftPage":									for(i = 0; i < leftPage.numChildren; i++){										children.push(leftPage.getChildAt(i));									}									for(i = 0; i < children.length ; i++){										children[i].parent.removeChild(children[i]);									}									if(bg) 										leftPage.addChildAt(_pageBG, 0);									leftPage.addChild(_pages[_currentPage+dif].src);																		if(_pages[_currentPage+dif].url != ""){										leftPage.buttonMode = true;										leftPage.addEventListener(MouseEvent.CLICK, pageClickedLeft, false, 0, true);									} else {										leftPage.buttonMode = false;										leftPage.removeEventListener(MouseEvent.CLICK, pageClickedLeft);									}																		break;																							}			// when page is an image: bitmap, jpg ect. 			if(_pages[_currentPage+dif].src is Bitmap){					_pages[_currentPage+dif].src.width = (_fbWidth/2) - (_boarder );					_pages[_currentPage+dif].src.height = (_fbHeight) - (_boarder * 2);					if(type == "leftPage" || type == "backPage" && _activePage == "rightCorner" || type == "frontPage" && _activePage == "leftCorner" ||						 type == "backPage" && _activePage == "rightTopCorner" || type == "frontPage" && _activePage == "leftTopCorner"){						_pages[_currentPage+dif].src.x = _boarder - (Number(_xml.@middleBoarder)/2);					}else{						_pages[_currentPage+dif].src.x = (Number(_xml.@middleBoarder)/2);					}												_pages[_currentPage+dif].src.y = _boarder;			} else {	// if it's not a Image										if(_pages[_currentPage+dif].src is MovieClip){ // if it is a MovieClip or Sprite						if(_pages[_currentPage+dif].src.mcWidth == undefined){							_pages[_currentPage+dif].src.mcWidth = _pages[_currentPage+dif].src.width;							_pages[_currentPage+dif].src.mcHeight = _pages[_currentPage+dif].src.height;						}						if(_resizeSwf){							_pages[_currentPage+dif].src.scaleY = ((_fbHeight - _boarder * 2 ) / _pages[_currentPage+dif].src.mcHeight);							_pages[_currentPage+dif].src.scaleX = (_fbWidth * 0.5 - _boarder) / _pages[_currentPage+dif].src.mcWidth;						} 						if(_pages[_currentPage+dif].src.getChildAt(_pages[_currentPage+dif].src.numChildren - 1)){							_pages[_currentPage+dif].src.getChildAt(_pages[_currentPage+dif].src.numChildren - 1).doubleClickEnabled = true;							_pages[_currentPage+dif].src.getChildAt(_pages[_currentPage+dif].src.numChildren - 1).addEventListener(MouseEvent.DOUBLE_CLICK, pageDoubleClick, false, 0, true);						}					} else if(_pages[_currentPage+dif].src && _pages[_currentPage+dif].src.getChildAt(0)){						_pages[_currentPage+dif].src.getChildAt(0).width = (_fbWidth/2) - (_boarder);						_pages[_currentPage+dif].src.getChildAt(0).height = (_fbHeight) - (_boarder * 2);						_pages[_currentPage+dif].src.getChildAt(0).doubleClickEnabled = true;						_pages[_currentPage+dif].src.getChildAt(0).addEventListener(MouseEvent.DOUBLE_CLICK, pageDoubleClick, false, 0, true);					}										if(_pages[_currentPage+dif].src){						if(_pages[_currentPage+dif].src.getChildAt(0))							_pages[_currentPage+dif].src.y = ((_fbHeight) - _pages[_currentPage+dif].src.getChildAt(0).height) /2;												if(_pages[_currentPage+dif].src is MovieClip && _resizeSwf){							_pages[_currentPage+dif].src.y = _boarder;						} else if(_pages[_currentPage+dif].src is MovieClip){							_pages[_currentPage+dif].src.y = (_fbHeight - _pages[_currentPage+dif].src.mcHeight) * 0.5;						}												if(type == "leftPage" || type == "backPage" && _activePage == "rightCorner" || type == "frontPage" && _activePage == "leftCorner" ||							 type == "backPage" && _activePage == "rightTopCorner" || type == "frontPage" && _activePage == "leftTopCorner"){							_pages[_currentPage+dif].src.x = _boarder - (Number(_xml.@middleBoarder)/2);						}else{							_pages[_currentPage+dif].src.x = (Number(_xml.@middleBoarder)/2);						}						}			}				}		private function pageClickedLeft(e:MouseEvent):void {						if(_pages[_currentPage].url != ""){				if(_pages[_currentPage].target != "")					navigateToURL(new URLRequest(_pages[_currentPage].url), _pages[_currentPage].target);				else						navigateToURL(new URLRequest(_pages[_currentPage].url), "_blank");				}		}		private function pageClickedRight(e:MouseEvent):void {						if(_pages[_currentPage+1].url != ""){				if(_pages[_currentPage+1].target != "")					navigateToURL(new URLRequest(_pages[_currentPage+1].url), _pages[_currentPage+1].target);				else						navigateToURL(new URLRequest(_pages[_currentPage+1].url), "_blank");				}		}			public function get gtp():int{			return _gtp;		}				public function checkLoaded(index:int):Boolean {			if(index != _numberOfAllPages - 1)				index += 2;			else 				index++;						if(index > _pagesLoaded || index == _currentPage || index == _currentPage+1)				return false;			else				return true;		}		public function gotoPage(index:int, tmp:Boolean, fast:Boolean = false):void {			/* This is also a huge function, but its really easy, if we want to go to some page, 			 * we need to call this function, first it checks if the page we wish to see is loaded, 			 * if not it shows warning, otherwise the function check if the page we wish to see is			 * beyond the page we are currently looking at, if so we scroll the right page if not			 * we scroll the left page.			 */			 trace("gotopage");			 if(index > _numberOfAllPages){				 this.dispatchEvent(new CustomEvent(CustomEvent.ENABLE_UI));			 	_alert = new Alert(String(_xml.alert.pageNumber.@src), 2000);				stage.addChild(_alert);				_alert.x = stage.stageWidth / 2;				_alert.y = stage.stageHeight / 2;				_alert.addEventListener(CustomEvent.KILL, kill, false, 0, true);				return;			 }			 var ind:int = index;			 if(ind != _numberOfAllPages - 1)				 ind += 2;			 else 				 ind++;			 			 //trace(ind);			 						 if(ind > _pagesLoaded){				 this.dispatchEvent(new CustomEvent(CustomEvent.ENABLE_UI));				 _alert = new Alert(String(_xml.alert.loading.@src), 2000);				 stage.addChild(_alert);				 _alert.x = stage.stageWidth / 2;				 _alert.y = stage.stageHeight / 2;				 _alert.addEventListener(CustomEvent.KILL, kill, false, 0, true);				 return;			 }			 			 if(index == _currentPage || index == _currentPage+1){				 trace("PAGE ALREADY DISPLAYED");				 this.dispatchEvent(new CustomEvent(CustomEvent.ENABLE_UI));				 return;			 }			 				var children:Array = new Array();			var i:int = 0;						_gotoPage = tmp;			interactive(false, 0);						this.removeEventListener(Event.ENTER_FRAME, tweenBack);												if(this._fbm != null && this.contains(_fbm))				this.removeChild(_fbm);									if (index > _currentPage){				if(_currentPage + 3 > _pagesLoaded){					_alert = new Alert(String(_xml.alert.loading.@src), 3000);					stage.addChild(_alert);					_alert.x = stage.stageWidth / 2;					_alert.y = stage.stageHeight / 2;					_alert.addEventListener(CustomEvent.KILL, kill, false, 0, true);					return;				}				_activePage = "rightCorner";									setupMasks();					if(index % 2 == 0)					index --;								_nopch = Math.floor((index - _currentPage)/2);								fillPage(1, "frontPage", true);						// here we setup page on the right position 									_fbm.frontPage.x= -_fbWidth/2;				_fbm.frontPage.y= -_fbHeight;					fillPage(index-_currentPage, "backPage", true);		// here we setup page on the right position 								if(index + 1 < _pages.length){										fillPage(index-_currentPage+1, "rightPage", true);	// here we setup page on the right position 				} else {										for(i = 0; i < rightPage.numChildren; i++){						children.push(rightPage.getChildAt(i));					}					for(i = 0; i < children.length ; i++){						children[i].parent.removeChild(children[i]);					}				}								_mouseX = _fbWidth-100;				_mouseY = _fbHeight-100;				tweenRight(fast);							} else if (index < _currentPage){								_activePage = "leftCorner";								setupMasks();									if(index % 2 == 0)					index --;								_nopch = Math.floor((_currentPage - index)/2);												fillPage(0, "frontPage", true);							// here we setup page on the right position 									_fbm.frontPage.x= -_fbWidth;				_fbm.frontPage.y= -_fbHeight;					fillPage(index - _currentPage + 1, "backPage", true);	// here we setup page on the right position 								if(index > -1){					fillPage(index - _currentPage, "leftPage", true);	// here we setup page on the right position 				} else {										for(i = 0; i < leftPage.numChildren; i++){						children.push(leftPage.getChildAt(i));					}					for(i = 0; i < children.length ; i++){						children[i].parent.removeChild(children[i]);					}				}								_mouseX = 100;				_mouseY = _fbHeight-100;				tweenLeft(fast);							}		}		private function setupRightPage():void {			/* This function is called when one of the right corners is rolled over, 			 * in this function pages from _page array are deployed on a proper positions			 * also the setupMasks function is called, to setup masks.			 */			setupMasks();							fillPage(1, "frontPage", true);			_fbm.frontPage.x= -_fbWidth/2;			_fbm.frontPage.y= -_fbHeight;						fillPage(2, "backPage", true);					if(_currentPage + 3 < _pages.length){				fillPage(3, "rightPage", true);			} else {				var children:Array = new Array();				for(var i:int = 0; i < rightPage.numChildren; i++){					children.push(rightPage.getChildAt(i));				}				for(i = 0; i < children.length ; i++){					children[i].parent.removeChild(children[i]);				}			}			}		private function setupLeftPage():void {			/* This function is called when one of the left corners is rolled over, 			 * in this function pages from _page array are deployed on a proper positions			 * also the setupMasks function is called, to setup masks.			 */			setupMasks();				fillPage(0, "frontPage", true);			_fbm.frontPage.x = -_fbWidth;			_fbm.frontPage.y = -_fbHeight;			fillPage(-1, "backPage", true);					if(_currentPage - 2 >= 0){				fillPage(-2, "leftPage", true);			} else if (leftPage.numChildren > 0) {				var children:Array = new Array();				for(var i:int = 0; i < leftPage.numChildren; i++){					children.push(leftPage.getChildAt(i));				}				for(i = 0; i < children.length ; i++){					children[i].parent.removeChild(children[i]);				}			}					}		private function setupMasks():void {			/* This function setups the properties of the masks and shadows that			 * are used in the flipbook, first the new FlipBookMasks object			 * is created then it's properties are setup, after that the alpha, x, y, width and height of the			 *  shadows is setuped.			 */			_fbm = new FlipBookMasks();			_fbm.mouseEnabled = false;			_fbm.mouseChildren = false;			this.addChild(_fbm);						this.setChildIndex(cornerRight, numChildren - 1);			_fbm.x = _fbWidth;			_fbm.y = _fbHeight;						if(_currentPage > -1 )				_cs.left.alpha = Number(_xml.shadows.inner.@src);			else 				_cs.left.alpha = 0;							if(_currentPage == 1 && _activePage == "leftCorner" || _currentPage == 1 && _activePage == "leftTopCorner")				_cs.left.alpha = 0;				if(_currentPage == _pages.length - 3 && _activePage == "rightCorner" || _currentPage == _pages.length - 3 && _activePage == "rightTopCorner")				_cs.right.alpha = 0;			else 				_cs.right.alpha = Number(_xml.shadows.inner.@src);							if(_currentPage == _pages.length - 1 && _activePage == "leftCorner" || _currentPage == _pages.length - 1 && _activePage == "leftTopCorner")				_cs.right.alpha = 0;										_fbm.sm2.y =  _fbm.sm.y = -_fbHeight;			_fbm.sm2.height = _fbm.sm.height = _fbHeight;			_fbm.sm2.x = _fbm.sm.x = -_fbWidth;			_fbm.sm2.width = _fbm.sm.width = _fbWidth;			_fbm.ps.alpha = (_xml.shadows.pageShadow.@src);				_fbm.cs.alpha = (_xml.shadows.curveGlow.@src);			_fbm.ips.alpha = Number(_xml.shadows.innerPageShadow.@src);			_fbm.csm.width = _fbWidth/2;			_fbm.csm.height = _fbHeight;																																										}				private function mouseMove(e:MouseEvent):void {			/* This is one of the most important function, the main task			 * is to set the position of the x and y of the corner which are called			 * _mouseX and _mouseY, we have two diferent sets of instruction for lower			 * corners the first part and for the upper the second part, at the end of this function			 * we use tweener to tween our _mouseX and _mouseY from the old value to the new one.			 */			 			var newMouseX:Number;			var newMouseY:Number;			newMouseX = mouseX;			newMouseY = mouseY;			if(_activePage != "rightTopCorner" && _activePage != "leftTopCorner"){				if(mouseY <= _fbHeight){					_cornerr = Math.sqrt(Math.pow(mouseX - (_fbWidth * 0.5), 2) + Math.pow(mouseY - _fbHeight, 2));										if(_cornerr > _fbWidth/2){						newMouseX = (_fbWidth/2) + ((_fbWidth/2) / _cornerr) * (mouseX - (_fbWidth/2));						newMouseY = _fbHeight + ((_fbWidth/2) / _cornerr) * (mouseY - _fbHeight);					}				}else{					_cornerr = Math.sqrt(Math.pow(mouseX - (_fbWidth/2), 2) + Math.pow(mouseY, 2));					_circler = Math.sqrt(Math.pow((_fbWidth/2), 2) + Math.pow((_fbHeight), 2));					_pageAngle = -Math.atan((mouseY) / (mouseX - (_fbWidth/2))) * _rtd;					if(_pageAngle>0)						_pageAngle = _pageAngle-180;					if(_cornerr > _circler){						newMouseX = (_fbWidth/2) + Math.sin((_pageAngle + 90) * _dtr) * _circler;						newMouseY = Math.cos((_pageAngle + 90) * _dtr) * _circler;						if(newMouseX <= 0){							newMouseX = 0; 							newMouseY = _fbHeight;						} else if(newMouseX >= _fbWidth) {							newMouseX = _fbWidth; 							newMouseY = _fbHeight;						}					}				}			} else {				if(mouseY >= 0){					_cornerr = Math.sqrt(Math.pow(mouseX - (_fbWidth * 0.5), 2) + Math.pow(mouseY, 2));										if(_cornerr > _fbWidth/2){						newMouseX = (_fbWidth/2) + ((_fbWidth/2) / _cornerr) * (mouseX - (_fbWidth/2));						newMouseY = 0 + ((_fbWidth/2) / _cornerr) * (mouseY);					}					if( newMouseX < 0){						newMouseX = 0;					}				}else{					_cornerr = Math.sqrt(Math.pow(mouseX - (_fbWidth *0.5), 2) + Math.pow(-(mouseY - _fbHeight), 2));					_circler = Math.sqrt(Math.pow((_fbWidth * 0.5), 2) + Math.pow((_fbHeight), 2));					_pageAngle = -Math.atan((-(mouseY - _fbHeight)) / (mouseX - (_fbWidth/2))) * _rtd;					if(_pageAngle>0)						_pageAngle = _pageAngle-180;					if(_cornerr > _circler){						newMouseX = (_fbWidth/2) + Math.sin((_pageAngle + 90) * _dtr) * _circler;						newMouseY = _fbHeight - Math.cos((_pageAngle + 90) * _dtr) * _circler;						if(newMouseX <= 0){							newMouseX = 0; 							newMouseY = 0;						} else if(newMouseX >= _fbWidth) {							newMouseX = _fbWidth; 							newMouseY = 0;						}					}				}			}			// here we check which corner is beeing dragged and we tween it to the new position			if(_activePage == "rightCorner" && Math.sqrt(Math.pow(_fbWidth - newMouseX, 2)) > 100 || _activePage == "rightCorner" && Math.sqrt(Math.pow(_fbHeight - newMouseY, 2)) > 100 ) {								TweenMax.to(this, Math.sqrt(Math.pow(_mouseX - newMouseX, 2))/300, {_mouseX:newMouseX, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, Math.sqrt(Math.pow(_mouseY - newMouseY, 2))/300, {_mouseY:newMouseY, ease:Expo.easeOut });			} else if (_activePage == "rightCorner") {				TweenMax.to(this, Math.sqrt(Math.pow(_mouseX - newMouseX, 2))/25, {_mouseX:newMouseX, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, Math.sqrt(Math.pow(_mouseY - newMouseY, 2))/25, {_mouseY:newMouseY, ease:Expo.easeOut });			}						if(_activePage == "rightTopCorner" && Math.sqrt(Math.pow(_fbWidth - newMouseX, 2)) > 100 || _activePage == "rightTopCorner" && Math.sqrt(Math.pow(0 - newMouseY, 2)) > 100 ) {				TweenMax.to(this, Math.sqrt(Math.pow(_mouseX - newMouseX, 2))/300, {_mouseX:newMouseX, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, Math.sqrt(Math.pow(_mouseY - newMouseY, 2))/300, {_mouseY:newMouseY, ease:Expo.easeOut });			} else if(_activePage == "rightTopCorner") {				TweenMax.to(this, Math.sqrt(Math.pow(_mouseX - newMouseX, 2))/25, {_mouseX:newMouseX, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, Math.sqrt(Math.pow(_mouseY - newMouseY, 2))/25, {_mouseY:newMouseY, ease:Expo.easeOut });			}						if(_activePage == "leftCorner" && Math.sqrt(Math.pow(0 - newMouseX, 2)) > 100 || _activePage == "leftCorner" && Math.sqrt(Math.pow(_fbHeight - newMouseY, 2)) > 100 ) {				TweenMax.to(this, Math.sqrt(Math.pow(_mouseX - newMouseX, 2))/300, {_mouseX:newMouseX, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, Math.sqrt(Math.pow(_mouseY - newMouseY, 2))/300, {_mouseY:newMouseY, ease:Expo.easeOut });			} else if(_activePage == "leftCorner") {				TweenMax.to(this, Math.sqrt(Math.pow(_mouseX - newMouseX, 2))/25, {_mouseX:newMouseX, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, Math.sqrt(Math.pow(_mouseY - newMouseY, 2))/25, {_mouseY:newMouseY, ease:Expo.easeOut });			}						if(_activePage == "leftTopCorner" && Math.sqrt(Math.pow(0 - newMouseX, 2)) > 100 || _activePage == "leftTopCorner" && Math.sqrt(Math.pow(0 - newMouseY, 2)) > 100 ) {				TweenMax.to(this, Math.sqrt(Math.pow(_mouseX - newMouseX, 2))/300, {_mouseX:newMouseX, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, Math.sqrt(Math.pow(_mouseY - newMouseY, 2))/300, {_mouseY:newMouseY, ease:Expo.easeOut });			} else if(_activePage == "leftTopCorner") {				TweenMax.to(this, Math.sqrt(Math.pow(_mouseX - newMouseX, 2))/25, {_mouseX:newMouseX, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, Math.sqrt(Math.pow(_mouseY - newMouseY, 2))/25, {_mouseY:newMouseY, ease:Expo.easeOut });			}			e.updateAfterEvent();			}		private function tweenRight(fast:Boolean = false):void {			/* gotoPage function ueses this function to tween the page from right to left			 * then it looks like it was dragged, it's just a simple tween			 */			var td:Number;			var speed:Number;			_rightChanged = true;			td = Math.abs(_mouseY - _fbHeight) + Math.abs(0 - _mouseX);			speed = td /600;						if(fast){				this.dispatchEvent(new CustomEvent(CustomEvent.DISABLE_UI));				TweenMax.to(this, 0, {_mouseX:0, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, 0, {_mouseY:_fbHeight, ease:Expo.easeOut, onUpdate:callSwapPages});			} else {				this.dispatchEvent(new CustomEvent(CustomEvent.DISABLE_UI));				TweenMax.to(this, speed, {_mouseX:0, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, speed, {_mouseY:_fbHeight, ease:Expo.easeOut, onUpdate:callSwapPages});			}		}		private function tweenLeft(fast:Boolean = false):void {			/* gotoPage function ueses this function to tween the page from left to right			 * then it looks like it was dragged, it's just a simple tween			 */			var td:Number;			var speed:Number;			td = Math.abs(_mouseY - _fbHeight) + Math.abs(_fbWidth - _mouseX);			_leftChanged = true;			td = Math.abs(_mouseY - _fbHeight) + Math.abs(_fbWidth - _mouseX);			speed = td /600;						if(fast){				this.dispatchEvent(new CustomEvent(CustomEvent.DISABLE_UI));				TweenMax.to(this, 0, {_mouseX:_fbWidth, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, 0, {_mouseY:_fbHeight, ease:Expo.easeOut, onUpdate:callSwapPages});			} else {				this.dispatchEvent(new CustomEvent(CustomEvent.DISABLE_UI));				TweenMax.to(this, speed, {_mouseX:_fbWidth, ease:Expo.easeOut, onUpdate:renderPage});				TweenMax.to(this, speed, {_mouseY:_fbHeight, ease:Expo.easeOut, onUpdate:callSwapPages});			}		}			private function tweenBack(e:Event = null):void {			/* This function is fired when the corner of the page is released, depending on which corner was dragged the			 * page is tweened back to its original position if the mouseX and mouseY haven't passed the middle of the book			 * otherwise the page is tweened to the oposite corner, and that result in page change			 */			var td:Number;			var speed:Number;			_nopch = 1;				if(_releaseX < _fbWidth / 2  && _activePage == "rightCorner" || _releaseX < _fbWidth / 2  && _activePage == "rightTopCorner"){				_rightChanged = true;				this.dispatchEvent(new CustomEvent(CustomEvent.DISABLE_UI));				if(_activePage == "rightCorner"){					td = Math.abs(_mouseY - _fbHeight) + Math.abs(0 - _mouseX);					speed = td /300;					TweenMax.to(this, speed, {_mouseX:0, ease:Expo.easeOut, onUpdate:renderPage});					TweenMax.to(this, speed, {_mouseY:_fbHeight, ease:Expo.easeOut, onUpdate:callSwapPages});				} else {					td = Math.abs(0 - _mouseY) + Math.abs(0 - _mouseX);					speed = td / 300;					TweenMax.to(this, speed, {_mouseX:0, ease:Expo.easeOut, onUpdate:renderPage});					TweenMax.to(this, speed, {_mouseY:0, ease:Expo.easeOut, onUpdate:callSwapPages});				}		 			} else if (_releaseX > _fbWidth / 2  && _activePage == "rightCorner" || _releaseX > _fbWidth / 2  && _activePage == "rightTopCorner") {				_rightChanged = false;				this.dispatchEvent(new CustomEvent(CustomEvent.DISABLE_UI));				if(_activePage == "rightCorner"){					td = Math.abs(_mouseY - _fbHeight) + Math.abs(_fbWidth - _mouseX);					speed = td /200;					TweenMax.to(this, speed, {_mouseX:_fbWidth, ease:Expo.easeOut, onUpdate:renderPage});					TweenMax.to(this, speed, {_mouseY:_fbHeight, ease:Expo.easeOut, onUpdate:callSwapPages});				} else {					td = Math.abs(0 - _mouseY ) + Math.abs(_fbWidth - _mouseX);					speed = td /200;					TweenMax.to(this, speed, {_mouseX:_fbWidth, ease:Expo.easeOut, onUpdate:renderPage});					TweenMax.to(this, speed, {_mouseY:0, ease:Expo.easeOut, onUpdate:callSwapPages});				}				} else if(_releaseX > _fbWidth / 2  && _activePage == "leftCorner" || _releaseX > _fbWidth / 2  && _activePage == "leftTopCorner"){				_leftChanged = true;				this.dispatchEvent(new CustomEvent(CustomEvent.DISABLE_UI));				if(_activePage == "leftCorner"){					td = Math.abs(_mouseY - _fbHeight) + Math.abs(_fbWidth - _mouseX);					speed = td /300;					TweenMax.to(this, speed, {_mouseX:_fbWidth, ease:Expo.easeOut, onUpdate:renderPage});					TweenMax.to(this, speed, {_mouseY:_fbHeight, ease:Expo.easeOut, onUpdate:callSwapPages});				} else {					td = Math.abs( 0 - _mouseY) + Math.abs(_fbWidth - _mouseX);					speed = td /300;					TweenMax.to(this, speed, {_mouseX:_fbWidth, ease:Expo.easeOut, onUpdate:renderPage});					TweenMax.to(this, speed, {_mouseY:0, ease:Expo.easeOut, onUpdate:callSwapPages});				}												} else if (_releaseX < _fbWidth / 2  && _activePage == "leftCorner" || _releaseX < _fbWidth / 2  && _activePage == "leftTopCorner"){				_leftChanged = false;				this.dispatchEvent(new CustomEvent(CustomEvent.DISABLE_UI));				if(_activePage == "leftCorner"){					td = Math.abs(_mouseY - _fbHeight) + Math.abs(0 - _mouseX);					speed = td /200;					TweenMax.to(this, speed, {_mouseX:0, ease:Expo.easeOut, onUpdate:renderPage});					TweenMax.to(this, speed, {_mouseY:_fbHeight, ease:Expo.easeOut, onUpdate:callSwapPages});				} else {					td = Math.abs(0 - _mouseY) + Math.abs(0 - _mouseX);					speed = td /200;					TweenMax.to(this, speed, {_mouseX:0, ease:Expo.easeOut, onUpdate:renderPage});					TweenMax.to(this, speed, {_mouseY:0 , ease:Expo.easeOut, onUpdate:callSwapPages});				}								}									}		private function callSwapPages():void {			var td:Number;			// here we count the distance between the destination point and the curnet x and y of the corner			if(_activePage == "leftCorner" && _leftChanged == false)					td = Math.abs(_mouseY - _fbHeight) + Math.abs(0 - _mouseX);			else if(_activePage == "leftTopCorner" && _leftChanged == false)					td = Math.abs(0 - _mouseY) + Math.abs(0 - _mouseX);			else if(_activePage == "leftCorner" && _leftChanged == true)					td = Math.abs(_mouseY - _fbHeight) + Math.abs(_fbWidth - _mouseX);			else if(_activePage == "leftTopCorner" && _leftChanged == true)					td = Math.abs( 0 - _mouseY) + Math.abs(_fbWidth - _mouseX);			else if(_activePage == "rightCorner" && _rightChanged == false)					td = Math.abs(_mouseY - _fbHeight) + Math.abs(_fbWidth - _mouseX);			else if(_activePage == "rightTopCorner" && _rightChanged == false)					td = Math.abs(0 - _mouseY ) + Math.abs(_fbWidth - _mouseX);			else if(_activePage == "rightCorner" && _rightChanged == true)					td = Math.abs(_mouseY - _fbHeight) + Math.abs(0 - _mouseX);			else if(_activePage == "rightTopCorner" && _rightChanged == true)					td = Math.abs(0 - _mouseY) + Math.abs(0 - _mouseX);			// when it's less then 50 we hide the inner shadow			if(td <= 50){				if(_fbm != null && !TweenMax.isTweening(_fbm.ips))					TweenMax.to(_fbm.ips, 0.5, {alpha:0});			}								if(td <= 2 && _rightChanged || td <= 2 && _leftChanged){				swapPages();				TweenMax.killTweensOf(this);			} else if (!_rightChanged && !_leftChanged && td <= 20){				swapPages();				TweenMax.killTweensOf(this);			}									}		private function swapPages():void {			/* this function is always called at the end of each page animation, it checks whether the page was change it also adds			 * the over and out event to the corner (because they where removed at the begeing) at the end we set the alpha of the middle shadow			 * to 0 and then we check if the mouse is over any of the corner, if it is we dispatch the roll over event			 */			this.dispatchEvent(new CustomEvent(CustomEvent.ENABLE_UI));			if(_rightChanged){				_currentPage += (2 * _nopch);				dispatchEvent(new CustomEvent(CustomEvent.PAGE_CHANGE, true, false));				}else if (_leftChanged){				_currentPage -= (2 * _nopch);				dispatchEvent(new CustomEvent(CustomEvent.PAGE_CHANGE, true, false));				}						if(_vp != null)						_vp.pouse();							if(_gotoPage){				_gotoPage = false;				interactive(true, 1);			}						if(_currentPage < -1)			_currentPage = -1;					var multiply:Number;						if(this._fbm != null && this.contains(_fbm))				this.removeChild(_fbm);							if(_mouseX > _fbWidth / 2 && _currentPage < _pages.length ){				if(_currentPage + 1 < _pages.length){				fillPage(1, "rightPage", true);				}			}else if(_mouseX < _fbWidth/2 && _currentPage < _pages.length){				fillPage(0, "leftPage", true);				}			_activePage = "none";			this.setChildIndex(cornerRight, this.numChildren-1);			this.setChildIndex(cornerLeft, this.numChildren-1);						if(_interactive && _pages.length - 1 != _currentPage){				cornerTopRight.visible = true;				cornerRight.visible = true;					cornerRight.buttonMode = cornerTopRight.buttonMode = true;			} else {				cornerTopRight.visible = false;				cornerRight.visible = false;								}						if(_pages.length - 1 != _currentPage){				cornerRight.mouseEnabled = true;				cornerTopRight.mouseEnabled = true;				cornerRight.addEventListener(MouseEvent.ROLL_OVER, cornerOver, false, 0, true);				cornerTopRight.addEventListener(MouseEvent.ROLL_OVER, cornerOver, false, 0, true);				cornerRight.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);				cornerTopRight.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);			}						_tween = _tweenBack = false;						_rightChanged = _leftChanged = false;						if(_currentPage > 0) {				if(_interactive){					cornerTopLeft.visible = true;					cornerLeft.visible = true;					}				cornerLeft.buttonMode = cornerTopLeft.buttonMode = true;				cornerLeft.mouseEnabled = cornerTopLeft.mouseEnabled = true;									cornerLeft.addEventListener(MouseEvent.ROLL_OVER, cornerOver, false, 0, true);											cornerTopLeft.addEventListener(MouseEvent.ROLL_OVER, cornerOver, false, 0, true);						cornerLeft.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);				cornerTopLeft.addEventListener(MouseEvent.ROLL_OUT, cornerRelease, false, 0, true);				} else {				cornerLeft.mouseEnabled = false;				cornerLeft.visible = false;				cornerTopLeft.mouseEnabled = false;				cornerTopLeft.visible = false;			}										if(_currentPage > -1 )				_cs.left.alpha = Number(_xml.shadows.inner.@src);			else 				_cs.left.alpha = 0; 							if(_currentPage == _pages.length - 1)				_cs.right.alpha = 0;			else				_cs.right.alpha = Number(_xml.shadows.inner.@src);								addChild(_cs);				if(mouseX > _fbWidth - 100 && mouseX < _fbWidth && mouseY < _fbHeight && mouseY > _fbHeight - 100){				cornerRight.dispatchEvent(new MouseEvent(MouseEvent.ROLL_OVER));			} else if (mouseX > 0 && mouseX < 100 && mouseY < _fbHeight && mouseY > _fbHeight - 100){				cornerLeft.dispatchEvent(new MouseEvent(MouseEvent.ROLL_OVER));			} else if (mouseX > 0 && mouseX < 100 && mouseY < 100 && mouseY > 0){				cornerTopLeft.dispatchEvent(new MouseEvent(MouseEvent.ROLL_OVER));			} else if (mouseX > _fbWidth - 100 && mouseX < _fbWidth && mouseY < 100 && mouseY > 0){				cornerTopRight.dispatchEvent(new MouseEvent(MouseEvent.ROLL_OVER));			}						if(_currentPage < 0 )				_pageNumber.pageNumber.text = "- | " + (_currentPage + 2);			else if((_currentPage + 1) == _numberOfAllPages)				_pageNumber.pageNumber.text =(_currentPage + 1 )+  " | -";			else				_pageNumber.pageNumber.text =(_currentPage + 1 )+  " | " + (_currentPage + 2);							var ar:Array = SWFAddress.getPathNames();			//trace("from fb = " + SWFAddress.getPath());			if(ar[0] != "category" ){			//	trace("zmien url");				if(ar.length > 2)					SWFAddress.setValue(_title +"/"+ (_currentPage+1) +"/"+ar[2]);						else					SWFAddress.setValue(_title +"/"+ (_currentPage+1));				}			_gtp = -1;			}		// RENDER PAGE //		private function renderPage():void {			/* This function is called each time the corner is moved, it basicly renders the animation of the page,			 * first the function check which corner is being dragge then it satups the rotatnio, x and y properties			 * for each mask and shadow, after that it check if we are close to the middle of the book if so			 * some of the shadows alpha is turned down to look more natural. The inside of each statment for each of			 * the corner is very similar.s			 */			var mr:Number = 0;				if(_activePage == "leftCorner"){				mr = Math.atan((_mouseY - _fbHeight) / _mouseX) * _rtd;				_fbm.pfm2.rotation = _fbm.pfm.rotation = 180;				_fbm.pfm2.x = _fbm.pfm.x = (_mouseX) / 2 - _fbWidth;				_fbm.pfm2.y = _fbm.pfm.y = (_mouseY - _fbHeight)/2;					_fbm.ips.x = _fbm.ps.x = _fbm.pfm.x;				_fbm.ips.y = _fbm.ps.y = _fbm.pfm.y;					_fbm.cs.x = _fbm.pfm.x;				_fbm.cs.y = _fbm.pfm.y;						_fbm.pfm2.rotation = _fbm.pfm.rotation = mr + _fbm.pfm.rotation;				_fbm.ips.rotation = _fbm.ps.rotation = _fbm.pfm.rotation;				_fbm.cs.rotation = _fbm.pfm.rotation;				_fbm.backPage.rotation = mr * 2;				_fbm.backPage.x = (_mouseX - _fbWidth) + (Math.sin(_fbm.backPage.rotation * _dtr) * _fbHeight) - 								(Math.cos(_fbm.backPage.rotation * _dtr) * _fbWidth/2);				_fbm.backPage.y = (_mouseY - _fbHeight) - (Math.cos(_fbm.backPage.rotation * _dtr) * _fbHeight) - 								(Math.sin(_fbm.backPage.rotation * _dtr) * _fbWidth/2);				_fbm.csm.rotation = _fbm.backPage.rotation;				_fbm.csm.x = _fbm.backPage.x;				_fbm.csm.y = _fbm.backPage.y;								if((-_fbm.pfm.x) == _fbWidth){					_fbm.backPage.x = _fbWidth * _fbHeight;					_fbm.csm.x = _fbm.backPage.x;				}												if((_mouseX - _fbWidth * 0.85) >= 0){					_fbm.ps.alpha = Number(_xml.shadows.pageShadow.@src) - ((_mouseX - _fbWidth * 0.85) / (_fbWidth * 0.15));					_fbm.cs.alpha = Number(_xml.shadows.curveGlow.@src) -((_mouseX - _fbWidth * 0.8) / (_fbWidth * 0.2));				}								if(isNaN(_fbm.pfm.rotation)){					_fbm.pfm.rotation = 90;					_fbm.ips.alpha = 0;				} else {					_fbm.ips.alpha = 1;				}								if(isNaN(_fbm.pfm2.rotation)){					_fbm.pfm2.rotation = 90;				}			} else if(_activePage == "rightCorner") {				mr = Math.atan((_mouseY - _fbHeight) / (_mouseX - _fbWidth)) * _rtd;				_fbm.pfm2.rotation =  _fbm.pfm.rotation = mr;				_fbm.pfm2.x = _fbm.pfm.x = (_mouseX - _fbWidth) / 2; 				_fbm.pfm2.y = _fbm.pfm.y = (_mouseY - _fbHeight) / 2;					_fbm.ips.x = _fbm.ps.x = _fbm.pfm.x;				_fbm.ips.y = _fbm.ps.y = _fbm.pfm.y;					_fbm.cs.x = _fbm.pfm.x;				_fbm.cs.y = _fbm.pfm.y;					_fbm.backPage.rotation = mr * 2;				_fbm.ips.rotation = _fbm.ps.rotation = _fbm.pfm.rotation;				_fbm.cs.rotation = _fbm.pfm.rotation;				_fbm.backPage.x = (_mouseX - _fbWidth) + (Math.sin(_fbm.backPage.rotation * _dtr) * _fbHeight);				_fbm.backPage.y = (_mouseY - _fbHeight) - (Math.cos(_fbm.backPage.rotation * _dtr) * _fbHeight);				_fbm.csm.rotation = _fbm.backPage.rotation;				_fbm.csm.x = _fbm.backPage.x;				_fbm.csm.y = _fbm.backPage.y;												if(_mouseX <= _fbWidth * 0.15){					_fbm.ps.alpha = ((_mouseX) / (_fbWidth * 0.15)) * Number(_xml.shadows.pageShadow.@src);					_fbm.cs.alpha = ((_mouseX) / (_fbWidth * 0.15)) * Number(_xml.shadows.curveGlow.@src);				}				if(_fbm.pfm.rotation == -90){					_fbm.ips.rotation =  _fbm.cs.rotation = _fbm.pfm.rotation = 89;					_fbm.ips.alpha = 0;				} else {					_fbm.ips.alpha = 1;				}								if(isNaN(_fbm.pfm.rotation)){					_fbm.ips.alpha = 0;				} 								if(_fbm.pfm2.rotation == -90){					_fbm.pfm2.rotation = 89;				}			} else if (_activePage == "rightTopCorner"){				mr = Math.atan(( _mouseY ) / (_mouseX - _fbWidth)) * _rtd;				_fbm.pfm2.rotation = _fbm.pfm.rotation = mr;				_fbm.pfm2.x = _fbm.pfm.x = (_mouseX - _fbWidth) / 2;				_fbm.pfm2.y = _fbm.pfm.y =  -_fbHeight + ((_mouseY)/2);				_fbm.ips.x = _fbm.ps.x = _fbm.pfm.x;				_fbm.ips.y = _fbm.ps.y = _fbm.pfm.y;					_fbm.cs.x = _fbm.pfm.x;				_fbm.cs.y = _fbm.pfm.y;					_fbm.backPage.rotation = mr * 2;				_fbm.ips.rotation = _fbm.ps.rotation = _fbm.pfm.rotation;				_fbm.cs.rotation = _fbm.pfm.rotation;				_fbm.backPage.x = (_mouseX - _fbWidth) ;				_fbm.backPage.y = ( - _fbHeight + _mouseY);				_fbm.csm.rotation = _fbm.backPage.rotation;				_fbm.csm.x = _fbm.backPage.x;				_fbm.csm.y = _fbm.backPage.y;				if(_mouseX <= _fbWidth * 0.15){					_fbm.ps.alpha = ((_mouseX) / (_fbWidth * 0.15)) * Number(_xml.shadows.pageShadow.@src);					_fbm.cs.alpha = ((_mouseX) / (_fbWidth * 0.15)) * Number(_xml.shadows.curveGlow.@src);				}				if(_fbm.pfm.rotation == 90){					_fbm.ips.rotation = _fbm.cs.rotation = _fbm.pfm.rotation = -89;					_fbm.ips.alpha = 0;				} else {					_fbm.ips.alpha = 1;				}								if(isNaN(_fbm.pfm.rotation)){					_fbm.ips.alpha = 0;				} 												if(_fbm.pfm2.rotation == 90){					_fbm.pfm2.rotation = -89;				}								} else if(_activePage == "leftTopCorner"){				mr = Math.atan((_mouseY) / _mouseX) * _rtd;				_fbm.pfm2.rotation = _fbm.pfm.rotation = 180;				_fbm.pfm2.x = _fbm.pfm.x = (_mouseX) / 2 - (_fbWidth);				_fbm.pfm2.y = _fbm.pfm.y = -_fbHeight + ((_mouseY)/2);				_fbm.ips.x = _fbm.ps.x = _fbm.pfm.x;				_fbm.ips.y = _fbm.ps.y = _fbm.pfm.y;					_fbm.cs.x = _fbm.pfm.x;				_fbm.cs.y = _fbm.pfm.y;						_fbm.pfm2.rotation = _fbm.pfm.rotation = mr + _fbm.pfm.rotation;				_fbm.ips.rotation = _fbm.ps.rotation = _fbm.pfm.rotation;				_fbm.cs.rotation = _fbm.pfm.rotation;				_fbm.backPage.rotation = mr * 2;				_fbm.backPage.x = (-_fbWidth + _mouseX) + (Math.sin(_fbm.backPage.rotation * _dtr) * _fbHeight) - 								(Math.cos(_fbm.backPage.rotation * _dtr) * _fbWidth/2) - (Math.sin(_fbm.backPage.rotation * _dtr) * _fbHeight);				_fbm.backPage.y =  (-_fbHeight + _mouseY) - (Math.cos(_fbm.backPage.rotation * _dtr) * _fbHeight) - 								(Math.sin(_fbm.backPage.rotation * _dtr) * _fbWidth/2) + (Math.cos(_fbm.backPage.rotation * _dtr) * _fbHeight);				_fbm.csm.rotation = _fbm.backPage.rotation;				_fbm.csm.x = _fbm.backPage.x;				_fbm.csm.y = _fbm.backPage.y;								if((-_fbm.pfm.x) == _fbWidth){					_fbm.backPage.x = _fbWidth * _fbHeight;					_fbm.csm.x = _fbm.backPage.x;				}												if((_mouseX - _fbWidth * 0.85) >= 0){					_fbm.ps.alpha = Number(_xml.shadows.pageShadow.@src) - ((_mouseX - _fbWidth * 0.85) / (_fbWidth * 0.15));					_fbm.cs.alpha = Number(_xml.shadows.curveGlow.@src) -((_mouseX - _fbWidth * 0.8) / (_fbWidth * 0.2));				}								if(isNaN(_fbm.pfm.rotation)){					_fbm.pfm.rotation = -90;					_fbm.ips.alpha = 0;				} else {					_fbm.ips.alpha = 1;				}								if(_fbm.pfm.rotation == -90)					_fbm.ips.alpha = 0;								if(isNaN(_fbm.pfm2.rotation)){					_fbm.pfm2.rotation = -90;				}			}		} 		// GET //		public function get fbWidth():int {			if(int(_xml.@width) == 0 && int(_xml.@height) == 0 && _fbHeight != stage.stageHeight - 100 )				_fbWidth = ((stage.stageHeight - 125) * Number(_xml.@proportion))*2;						return _fbWidth;							// return the width of the flipbook		}		public function get fbHeight():int {			if(int(_xml.@width) == 0 && int(_xml.@height) == 0 && _fbHeight != stage.stageHeight - 100 )				_fbHeight = stage.stageHeight - 125;						return _fbHeight;							// return the height of the flipbook			}		public function get pages():Array {			var tmp:Array = new Array();			if(_reverse){				for(var i:int = _pages.length-1; i >= 0; i--){					tmp.push(_pages[i].src);				}				} else {				for(i = 0; i < _pages.length; i++){					tmp.push(_pages[i].src);				}				}			return tmp;									// return the pages array which contains all the pages		}		public function set title(tmp:String):void {			_title = tmp;		}				public function get xml():XML{			return _xml;								// return the xml		}		public function get currentPage():int{			return _currentPage;						//  returns the index of currently opened page		}		public function get reverse():Boolean {			return _reverse;		}		// SET //		public function set xml(tmp:XML):void {			_xml = tmp;									// set xml, the call xmlLoaded function 			xmlLoaded();		}		public function set startPosition(tmp:int):void {			_whereToStart = tmp;		}		// RESIZE FUNCTION //		protected function onResize(e:Event):void {						// this function is called when the stage is resized, all the elements of the flip book are adjusted.			if(int(_xml.@width) == 0 && int(_xml.@height) == 0 && _fbHeight != stage.stageHeight - 100 ){				_fbHeight = stage.stageHeight - 125;				_fbWidth = ((stage.stageHeight - 125) * Number(_xml.@proportion))*2;								_goToPage.x = 0;				_imagePreloader.x = _fbWidth;				_goToPage.y = _imagePreloader.y = _fbHeight;																										if(_currentPage > -1)					fillPage(0, "leftPage", true);				if(_currentPage < _pages.length-1)						fillPage(1, "rightPage", true);									_pageNumber.x = _fbWidth/2;				_pageNumber.y = _fbHeight;					cornerTopRight.x = cornerRight.x = _fbWidth;				cornerLeft.y =  cornerRight.y = _fbHeight;				cornerTopLeft.y = cornerTopLeft.x = cornerTopRight.y = cornerLeft.x = 0;												_fbm.x = _fbm.y = leftPage.x = leftPage.y = rightPage.y = 0; 																			rightPage.x = _fbWidth/2;				_fbm.sm.y = -_fbHeight;																														_fbm.sm.height = _fbHeight;																										_fbm.sm.x = -_fbWidth;																											_fbm.sm.width = _fbWidth;									_cs.height = _fbHeight;					_cs.x = _fbWidth/2;				_csl.height = _fbHeight;					_csr.height =  _fbHeight;				}				if(stage != null){				_cover.width = stage.stageWidth;				_cover.height = stage.stageHeight;			}					}		private function videoPosition(e:CustomEvent):void {			var pageWidth:Number = (_fbWidth * 0.5) - _boarder;			var pageHeight:Number = (_fbHeight - (_boarder * 2));			e.target.x = Math.round((pageWidth - e.target.width) / 2);			e.target.y = Math.round((pageHeight - e.target.height ) / 2);			e.target.setPreloaderXY(pageWidth, pageHeight);		}		private function adjustToc(e:CustomEvent):void {			var pageWidth:Number = (_fbWidth * 0.5) - _boarder;			var pageHeight:Number = (_fbHeight - (_boarder * 2));						if(_resizeToc && stage){				var ratio:Number = e.target.height / e.target.width;				e.target.width = pageWidth - 50;				e.target.height = e.target.width * ratio;				if(e.target.height > pageHeight){					ratio = e.target.width / e.target.height;					e.target.height = pageHeight - 50;					e.target.width = e.target.height * ratio;				}			}						e.target.x = Math.round((pageWidth - e.target.width) / 2);			e.target.y = Math.round((pageHeight - e.target.height ) / 2);		}		private function adjustContent(e:CustomEvent):void {			var pageWidth:Number = (_fbWidth * 0.5) - _boarder;			var pageHeight:Number = (_fbHeight - (_boarder * 2));			if(_resizeContent && stage){				var ratio:Number = e.target.height / e.target.width;				e.target.width = pageWidth - 50;				e.target.height = e.target.width * ratio;				if(e.target.height > pageHeight){					ratio = e.target.width / e.target.height;					e.target.height = pageHeight - 50;					e.target.width = e.target.height * ratio;				}			}						e.target.x = Math.round((pageWidth - e.target.width) / 2);			e.target.y = Math.round((pageHeight - e.target.height ) / 2);		}		public function interactive(tmp:Boolean, change:int = 0):void {			// this function is used to set the interactivity of the book if set to false,			// book stops responding to all the mouse event, when set to true book acts normaly 			_interactive = tmp;			trace("INTERACTIVE = " + _interactive + " " + change);			if(tmp){				if(_pages.length - 1 != _currentPage){					cornerTopRight.buttonMode = cornerRight.buttonMode = true;					cornerTopRight.visible = cornerRight.visible = true;					} else {					cornerTopRight.buttonMode = cornerRight.buttonMode = false;					cornerTopRight.visible = cornerRight.visible = false;					}				if(_currentPage > 0) {					cornerTopLeft.buttonMode = cornerLeft.buttonMode =  true;					cornerLeft.visible =  cornerTopLeft.visible = true;				} else {					cornerTopLeft.buttonMode = cornerLeft.buttonMode =  false;					cornerLeft.visible =  cornerTopLeft.visible = false;				}								} else {				cornerTopRight.buttonMode = cornerTopLeft.buttonMode = cornerLeft.buttonMode = cornerRight.buttonMode = false;				cornerTopRight.visible = cornerTopLeft.visible = cornerLeft.visible = cornerRight.visible = false;							}		}			// REMOVE FUNCTION //		protected function onRemove(e:Event):void {			// this function is called when the book is removed from stage, it removes all the objects form the stage and sets its values to null to free the memory			stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMove);			stage.removeEventListener(Event.RESIZE, onResize);			stage.removeEventListener(MouseEvent.MOUSE_UP, cornerRelease);			_pages = null;			trace("kill10");			TweenMax.killTweensOf(this);			if(_fbm != null && this.contains(_fbm)){				this.removeChild(_fbm);				_fbm = null;			}			if(leftPage != null && this.contains(leftPage)){				this.removeChild(leftPage);				leftPage = null;			}			if(rightPage != null && this.contains(rightPage)){				this.removeChild(rightPage);				rightPage = null;			}			if(_cs != null && this.contains(_cs)){				this.removeChild(_cs);				_cs = null;			}			if(_csr != null && this.contains(_csr)){				this.removeChild(_csr);				_csr = null;			}			if(_csl != null && this.contains(_csl)){				this.removeChild(_csl);				_csl = null;			}			if(_pageBG != null && this.contains(_pageBG)){				this.removeChild(_pageBG);				_pageBG = null;			}		}		// THE END, I HOPE YOU FOUND MY COMMENTS USEFUL ;)	}}